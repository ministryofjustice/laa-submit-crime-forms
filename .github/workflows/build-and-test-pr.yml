name: Test, Build, Scan & Deploy

on:
  pull_request:
    branches:
      - main

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  security-events: write
  checks: write

env:
  RACK_ENV: test
  RAILS_ENV: test

jobs:
  # ============================================================================
  # PHASE 1: Fast quality checks (run in parallel)
  # ============================================================================
  
  rubocop:
    name: Code quality - Rubocop
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Ruby and install gems
        uses: ruby/setup-ruby@v1
        with:
          bundler-cache: true

      - name: Run Rubocop linter
        run: bundle exec rubocop --format github --format progress

  helm-lint:
    name: Helm lint - ${{ matrix.environment }}
    runs-on: ubuntu-latest
    permissions:
      contents: read
    strategy:
      fail-fast: false
      matrix:
        environment: [dev, uat, prod]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install Helm
        uses: azure/setup-helm@v4
        with:
          version: '3.7.2'

      - name: Cache Python pip packages
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-yamllint
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: Install yamllint for YAML validation
        run: pip install yamllint

      - name: Lint Helm chart templates for ${{ matrix.environment }}
        run: |
          helm lint helm_deploy --values helm_deploy/values-${{ matrix.environment }}.yaml \
            --set redis.auth.password=dummy \
            --set postgresql.auth.password=dummy

      - name: Validate rendered Helm templates for ${{ matrix.environment }}
        run: |
          helm template --debug helm_deploy --values helm_deploy/values-${{ matrix.environment }}.yaml > /tmp/helm-output.yaml
          yamllint /tmp/helm-output.yaml -f github

  test:
    name: RSpec tests - ${{ matrix.test-type }}
    runs-on: ubuntu-latest
    permissions:
      contents: read
      checks: write
    strategy:
      fail-fast: false
      matrix:
        include:
          - test-type: "non-system"
            tag: "~type:system"
            needs-chrome: false
          - test-type: "system"
            tag: "type:system"
            needs-chrome: true
    env:
      BASE_DATABASE_HOST: localhost
      BASE_DATABASE_USERNAME: postgres
      BASE_DATABASE_PASSWORD: postgres
    services:
      postgres:
        image: postgres:13.12
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: laa_claim_non_standard_magistrate_fee_test
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Ruby and install gems
        uses: ruby/setup-ruby@v1
        with:
          bundler-cache: true

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version-file: '.nvmrc'
          cache: 'yarn'

      - name: Install JavaScript dependencies
        run: yarn install --frozen-lockfile

      - name: Build frontend assets
        run: |
          yarn build
          yarn build:css

      - name: Install Chrome for system tests
        if: matrix.needs-chrome
        uses: browser-actions/setup-chrome@v1
        with:
          chrome-version: stable

      - name: Set up test database
        run: |
          bundle exec rails db:setup
          bundle exec flatware fan rails db:test:prepare

      - name: Run RSpec tests (${{ matrix.test-type }})
        env:
          RUBYOPT: -W:no-deprecated
          INCLUDE_ACCESSIBILITY_SPECS: true
        run: bundle exec flatware rspec --tag ${{ matrix.tag }} --format progress

      - name: Upload code coverage results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: coverage-results-${{ matrix.test-type }}
          path: coverage

      - name: Upload Capybara screenshots (on test failure)
        if: failure() && matrix.needs-chrome
        uses: actions/upload-artifact@v4
        with:
          name: capybara-screenshots-${{ matrix.test-type }}
          path: tmp/capybara

  coverage:
    name: Process code coverage
    runs-on: ubuntu-latest
    needs: test
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Ruby and install gems
        uses: ruby/setup-ruby@v1
        with:
          bundler-cache: true

      - name: Download coverage results from all test types
        uses: actions/download-artifact@v4
        with:
          pattern: coverage-results-*
          path: coverage_results
          merge-multiple: true

      - name: Merge coverage results from both test types
        run: bundle exec rake simplecov:process_coverage

      - name: Check coverage meets 100% threshold
        run: |
          # SimpleCov generates coverage/index.html with the coverage percentage
          # Extract the coverage percentage and fail if it's not 100%
          if [ -f coverage/.last_run.json ]; then
            COVERAGE=$(ruby -e "require 'json'; data = JSON.parse(File.read('coverage/.last_run.json')); puts data['result']['line']")
            echo "Coverage: ${COVERAGE}%"
            if (( $(echo "$COVERAGE < 100" | bc -l) )); then
              echo "❌ Coverage is below 100% (${COVERAGE}%)"
              exit 1
            else
              echo "✅ Coverage is 100%"
            fi
          else
            echo "❌ Coverage results not found"
            exit 1
          fi

      - name: Upload final coverage artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: coverage-final
          path: coverage

  # ============================================================================
  # PHASE 2: Build Docker image (depends on tests passing)
  # ============================================================================

  build:
    name: Build and push Docker image to ECR
    runs-on: ubuntu-latest
    needs: [rubocop, test, helm-lint]
    permissions:
      id-token: write
      contents: read
    outputs:
      image-tag: ${{ steps.set-tags.outputs.image-tag }}
    env:
      ECR_REGISTRY_ID: ${{ secrets.ECR_REGISTRY_ID }}
      ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
      ECR_REGION: ${{ secrets.ECR_REGION }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials for ECR access
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.ECR_ROLE_TO_ASSUME }}
          aws-region: ${{ env.ECR_REGION }}
          mask-aws-account-id: true

      - name: Login to Amazon ECR
        id: login-ecr
        run: |
          aws ecr get-login-password --region ${ECR_REGION} | docker login \
            --username AWS --password-stdin \
            ${ECR_REGISTRY_ID}.dkr.ecr.${ECR_REGION}.amazonaws.com

      - name: Generate Docker image tags
        id: set-tags
        run: |
          IMAGE_TAG="branch-${{ github.sha }}"
          echo "image-tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "IMAGE_TAG=${IMAGE_TAG}" >> $GITHUB_ENV
          echo "APP_BUILD_DATE=$(date +%Y-%m-%dT%H:%M:%S%z)" >> $GITHUB_ENV
          echo "ECR_IMAGE=${ECR_REGISTRY_ID}.dkr.ecr.${ECR_REGION}.amazonaws.com/${ECR_REPOSITORY}" >> $GITHUB_ENV

      - name: Build Docker image and push to ECR
        run: |
          docker build \
            --build-arg APP_BUILD_DATE=${APP_BUILD_DATE} \
            --build-arg APP_BUILD_TAG=${{ github.sha }} \
            --build-arg APP_GIT_COMMIT=${{ github.sha }} \
            --build-arg APP_BRANCH_NAME=${{ github.ref_name }} \
            --tag ${ECR_IMAGE}:${IMAGE_TAG} \
            --file Dockerfile .
          
          docker push ${ECR_IMAGE}:${IMAGE_TAG}

  # ============================================================================
  # PHASE 3: Security scans and E2E tests (run in parallel after build)
  # ============================================================================

  trivy-scan:
    name: Trivy security scanning
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
      security-events: write
    needs: build
    env:
      ECR_REGISTRY_ID: ${{ secrets.ECR_REGISTRY_ID }}
      ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
      ECR_REGION: ${{ secrets.ECR_REGION }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials for ECR access
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.ECR_ROLE_TO_ASSUME }}
          aws-region: ${{ env.ECR_REGION }}
          mask-aws-account-id: true

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2
        with:
          mask-password: true

      - name: Scan filesystem for vulnerabilities
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-fs-results.sarif'
          severity: 'CRITICAL,HIGH'
          exit-code: '0'

      - name: Upload filesystem scan results to GitHub Security
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-fs-results.sarif'
          category: 'trivy-filesystem'

      - name: Scan Docker image for vulnerabilities
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'image'
          image-ref: '${{ env.ECR_REGISTRY_ID }}.dkr.ecr.${{ env.ECR_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:${{ needs.build.outputs.image-tag }}'
          format: 'sarif'
          output: 'trivy-image-results.sarif'
          severity: 'CRITICAL,HIGH'
          exit-code: '0'

      - name: Upload Docker image scan results to GitHub Security
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-image-results.sarif'
          category: 'trivy-image'

      - name: Scan infrastructure configuration for issues
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'config'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-config-results.sarif'
          severity: 'CRITICAL,HIGH'
          exit-code: '0'

      - name: Upload config scan results to GitHub Security
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-config-results.sarif'
          category: 'trivy-config'

  snyk-scan:
    name: Snyk security scanning
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    needs: build
    env:
      ECR_REGISTRY_ID: ${{ secrets.ECR_REGISTRY_ID }}
      ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
      ECR_REGION: ${{ secrets.ECR_REGION }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Ruby and install gems
        uses: ruby/setup-ruby@v1
        with:
          bundler-cache: true

      - name: Configure AWS credentials for ECR access
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.ECR_ROLE_TO_ASSUME }}
          aws-region: ${{ env.ECR_REGION }}
          mask-aws-account-id: true

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2
        with:
          mask-password: true

      - name: Pull Docker image from ECR for scanning
        run: docker pull ${ECR_REGISTRY_ID}.dkr.ecr.${ECR_REGION}.amazonaws.com/${ECR_REPOSITORY}:${{ needs.build.outputs.image-tag }}

      - name: Install Snyk CLI
        uses: snyk/actions/setup@master

      - name: Test dependencies for vulnerabilities and monitor
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        run: |
          snyk test --all-projects --severity-threshold=high
          snyk monitor --all-projects

      - name: Scan and monitor Docker container for vulnerabilities
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        run: snyk container monitor ${ECR_REGISTRY_ID}.dkr.ecr.${ECR_REGION}.amazonaws.com/${ECR_REPOSITORY}:${{ needs.build.outputs.image-tag }} --file=./Dockerfile

  e2e-test:
    name: End-to-end tests
    runs-on: ubuntu-latest
    needs: build
    permissions:
      id-token: write
      contents: read
    env:
      ECR_REGISTRY_ID: ${{ secrets.ECR_REGISTRY_ID }}
      ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
      ECR_REGION: ${{ secrets.ECR_REGION }}
      E2E_WORKING_DIR: /tmp/nsm-end-to-end-tests
    steps:
      - name: Configure AWS credentials for ECR access
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.ECR_ROLE_TO_ASSUME }}
          aws-region: ${{ env.ECR_REGION }}
          mask-aws-account-id: true

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2
        with:
          mask-password: true

      - name: Clone E2E test repository
        run: |
          git clone https://github.com/ministryofjustice/nsm-e2e-test.git ${{ env.E2E_WORKING_DIR }}

      - name: Pull application Docker images from ECR
        working-directory: ${{ env.E2E_WORKING_DIR }}
        env:
          NSCC_PROVIDER_IMAGE: ${{ env.ECR_REGISTRY_ID }}.dkr.ecr.${{ env.ECR_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:${{ needs.build.outputs.image-tag }}
        run: |
          echo "Pulling NSCC provider image: ${NSCC_PROVIDER_IMAGE}"
          docker pull ${NSCC_PROVIDER_IMAGE}

      - name: Start application services with Docker Compose
        working-directory: ${{ env.E2E_WORKING_DIR }}
        env:
          NSCC_PROVIDER_IMAGE: ${{ env.ECR_REGISTRY_ID }}.dkr.ecr.${{ env.ECR_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:${{ needs.build.outputs.image-tag }}
        run: |
          docker compose up -d
          docker compose ps

      - name: Wait for services to be ready
        working-directory: ${{ env.E2E_WORKING_DIR }}
        run: |
          echo "Waiting for services to be healthy..."
          timeout 120 bash -c 'until docker compose ps | grep -q "healthy"; do sleep 2; done' || true
          docker compose ps

      - name: Install Node.js dependencies for E2E tests
        working-directory: ${{ env.E2E_WORKING_DIR }}
        run: npm ci

      - name: Run Playwright E2E tests
        working-directory: ${{ env.E2E_WORKING_DIR }}
        run: npm run e2e-test

      - name: Output container logs on failure
        if: failure()
        working-directory: ${{ env.E2E_WORKING_DIR }}
        run: |
          echo "=== Docker Compose Services ==="
          docker compose ps
          echo ""
          echo "=== Container Logs ==="
          docker compose logs

      - name: Cleanup Docker containers
        if: always()
        working-directory: ${{ env.E2E_WORKING_DIR }}
        run: docker compose down -v

  # ============================================================================
  # PHASE 4: Deploy to dev environment (only after all checks pass)
  # ============================================================================

  deploy-feature-branch:
    name: Deploy feature branch to dev
    runs-on: ubuntu-latest
    needs: [build, trivy-scan, snyk-scan, e2e-test]
    permissions:
      id-token: write
      contents: read
    env:
      ECR_REGISTRY_ID: ${{ secrets.ECR_REGISTRY_ID }}
      ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
      ECR_REGION: ${{ secrets.ECR_REGION }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.ECR_ROLE_TO_ASSUME }}
          aws-region: ${{ env.ECR_REGION }}

      - name: Authenticate to Kubernetes cluster
        env:
          K8S_CLUSTER_NAME: ${{ secrets.AUTOGENERATED_SUBMIT_FORMS_DEV_K8S_CLUSTER_NAME }}
          K8S_CLUSTER_CERT: ${{ secrets.AUTOGENERATED_SUBMIT_FORMS_DEV_K8S_CLUSTER_CERT }}
          K8S_CLUSTER_URL: https://${{ secrets.AUTOGENERATED_SUBMIT_FORMS_DEV_K8S_CLUSTER_NAME }}
          K8S_NAMESPACE: ${{ secrets.AUTOGENERATED_SUBMIT_FORMS_DEV_K8S_NAMESPACE }}
          K8S_TOKEN: ${{ secrets.AUTOGENERATED_SUBMIT_FORMS_DEV_K8S_TOKEN }}
        run: |
          set +x
          echo -n "${K8S_CLUSTER_CERT}" | base64 -d > ./ca.crt
          kubectl config set-cluster ${K8S_CLUSTER_NAME} --certificate-authority=./ca.crt --server=${K8S_CLUSTER_URL}
          kubectl config set-credentials github-actions --token=${K8S_TOKEN}
          kubectl config set-context ${K8S_CLUSTER_NAME} --cluster=${K8S_CLUSTER_NAME} --user=github-actions --namespace=${K8S_NAMESPACE}
          kubectl config use-context ${K8S_CLUSTER_NAME}
          kubectl --namespace=${K8S_NAMESPACE} get pods

      - name: Install Helm
        uses: azure/setup-helm@v4
        with:
          version: '3.7.2'

      - name: Deploy feature branch to dev environment
        env:
          CIRCLE_BRANCH: ${{ github.head_ref }}
          CIRCLE_SHA1: ${{ github.sha }}
          AWS_ECR_REGISTRY_ID: ${{ env.ECR_REGISTRY_ID }}
          K8S_NAMESPACE: ${{ secrets.AUTOGENERATED_SUBMIT_FORMS_DEV_K8S_NAMESPACE }}
        run: ./bin/deploy dev

      - name: Output deployment URL to PR
        run: |
          BRANCH_RELEASE_NAME=$(echo "${{ github.head_ref }}" | tr '[:upper:]' '[:lower:]' | sed 's:^\w*\/::' | tr -s ' _/[]().' '-' | cut -c1-18 | sed 's/-$//')
          RELEASE_HOST="${BRANCH_RELEASE_NAME}-nscc-provider-dev.cloud-platform.service.justice.gov.uk"
          echo "### 🚀 Feature branch deployed!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**URL:** https://${RELEASE_HOST}" >> $GITHUB_STEP_SUMMARY
